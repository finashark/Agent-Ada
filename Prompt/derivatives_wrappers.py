
"""
derivatives_wrappers.py
-----------------------
Free, low-latency wrappers for Funding Rate & Open Interest using *native* exchange APIs:
- Binance USDⓈ-M Futures (REST)
- Bybit v5 (REST)
- OKX v5 (REST)
- Deribit v2 (HTTP JSON-RPC GET for public methods)

Design goals:
- Zero external API providers (free, public endpoints)
- Robust timeouts, retries, lightweight normalization
- Ready for Streamlit or any Python app

Author: Generated by ChatGPT (Finance - Business Finance)
License: MIT
"""

from __future__ import annotations

import os
import time
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

import requests


# ----------------------------
# Data models (normalized)
# ----------------------------

@dataclass
class FundingPoint:
    ts: int                    # unix ms
    rate: float                # funding rate as decimal (e.g., 0.0001 = 0.01%)
    exchange: str
    symbol: str                # canonical pair, e.g., "BTCUSDT" or "BTC-PERPETUAL" for Deribit


@dataclass
class OIPoint:
    ts: int                    # unix ms
    open_interest: float       # contracts or coin units (exchange-specific); see 'meta'
    exchange: str
    symbol: str
    meta: Dict[str, Any]       # carry native fields like valueInUsd if provided


# ----------------------------
# HTTP utils
# ----------------------------

DEFAULT_TIMEOUT = float(os.getenv("DERIVS_TIMEOUT", "15"))
RETRIES = int(os.getenv("DERIVS_RETRIES", "2"))

def _request_json(
    method: str,
    url: str,
    params: Optional[Dict[str, Any]] = None,
    headers: Optional[Dict[str, str]] = None,
    timeout: float = DEFAULT_TIMEOUT
) -> Any:
    """HTTP with basic retry/backoff; returns parsed JSON"""
    backoff = 0.8
    last_exc = None
    for i in range(RETRIES + 1):
        try:
            resp = requests.request(method, url, params=params, headers=headers, timeout=timeout)
            resp.raise_for_status()
            return resp.json()
        except Exception as e:
            last_exc = e
            if i == RETRIES:
                raise
            time.sleep(backoff * (2 ** i))
    if last_exc:
        raise last_exc


# ----------------------------
# Symbol helpers
# ----------------------------

def okx_swap_symbol(symbol: str) -> str:
    """Map 'BTCUSDT' -> 'BTC-USDT-SWAP'"""
    symbol = symbol.upper().replace("-", "").replace("_", "")
    if len(symbol) >= 6 and symbol.endswith("USDT"):
        base = symbol[:-4]
        return f"{base}-USDT-SWAP"
    if symbol.endswith("USD"):
        base = symbol[:-3]
        return f"{base}-USD-SWAP"
    # fallback
    return symbol

def deribit_perp_symbol(symbol: str) -> str:
    """Map 'BTCUSDT' or 'BTC' -> 'BTC-PERPETUAL' """
    sym = symbol.upper()
    if sym.endswith("USDT") or sym.endswith("USD"):
        sym = sym.replace("USDT","").replace("USD","")
    return f"{sym}-PERPETUAL"


# ----------------------------
# Binance USDⓈ-M Futures
# Docs:
#  - Funding history: GET /fapi/v1/fundingRate
#  - OI snapshot:    GET /fapi/v1/openInterest
#  - OI timeseries:  GET /futures/data/openInterestHist
# Base: https://fapi.binance.com
# ----------------------------

class BinanceFutures:
    def __init__(self, api_key: Optional[str] = None, base: str = "https://fapi.binance.com"):
        self.base = base.rstrip("/")
        self.api_key = api_key or os.getenv("BINANCE_API_KEY")
        self._hdr = {"X-MBX-APIKEY": self.api_key} if self.api_key else None

    def funding_history(self, symbol: str, start_ms: Optional[int]=None, end_ms: Optional[int]=None, limit: int=1000) -> List[FundingPoint]:
        url = f"{self.base}/fapi/v1/fundingRate"
        p = {"symbol": symbol.upper(), "limit": min(limit, 1000)}
        if start_ms: p["startTime"] = start_ms
        if end_ms:   p["endTime"]   = end_ms
        j = _request_json("GET", url, params=p, headers=self._hdr)
        out = []
        for it in j:
            # Binance returns fundingRate as string, e.g., "0.0001"
            out.append(FundingPoint(
                ts=int(it.get("fundingTime")),
                rate=float(it.get("fundingRate")),
                exchange="Binance",
                symbol=symbol.upper()
            ))
        return out

    def funding_latest(self, symbol: str) -> Optional[FundingPoint]:
        arr = self.funding_history(symbol, limit=1)
        return arr[-1] if arr else None

    def open_interest_snapshot(self, symbol: str) -> Optional[OIPoint]:
        url = f"{self.base}/fapi/v1/openInterest"
        p = {"symbol": symbol.upper()}
        j = _request_json("GET", url, params=p, headers=self._hdr)
        return OIPoint(
            ts=int(j.get("time")),
            open_interest=float(j.get("openInterest")),
            exchange="Binance",
            symbol=symbol.upper(),
            meta={}
        )

    def open_interest_history(self, symbol: str, period: str="1h", limit: int=30, start_ms: Optional[int]=None, end_ms: Optional[int]=None) -> List[OIPoint]:
        # Docs: /futures/data/openInterestHist with period in ["5m","15m","30m","1h","2h","4h","6h","12h","1d"]
        url = f"{self.base}/futures/data/openInterestHist"
        p = {"symbol": symbol.upper(), "period": period, "limit": min(limit, 500)}
        if start_ms: p["startTime"] = start_ms
        if end_ms:   p["endTime"]   = end_ms
        j = _request_json("GET", url, params=p, headers=self._hdr)
        out = []
        for it in j:
            out.append(OIPoint(
                ts=int(it.get("timestamp")),
                open_interest=float(it.get("sumOpenInterest")),
                exchange="Binance",
                symbol=symbol.upper(),
                meta={"sumOpenInterestValue": float(it.get("sumOpenInterestValue", "nan"))}
            ))
        return out


# ----------------------------
# Bybit v5
# Docs:
#  - Funding history: GET /v5/market/history-fund-rate (category=linear|inverse)
#  - Open interest:   GET /v5/market/open-interest (category=linear|inverse, intervalTime=5min|15min|30min|1h|4h|1d)
# Base: https://api.bybit.com
# ----------------------------

class BybitV5:
    def __init__(self, base: str = "https://api.bybit.com"):
        self.base = base.rstrip("/")

    @staticmethod
    def _category_from_symbol(symbol: str) -> str:
        # Heuristic: USDT margined -> linear; coin margined '...USD' -> inverse
        return "linear" if symbol.upper().endswith("USDT") else "inverse"

    def funding_history(self, symbol: str, limit: int=200, start_ms: Optional[int]=None, end_ms: Optional[int]=None) -> List[FundingPoint]:
        url = f"{self.base}/v5/market/history-fund-rate"
        p = {
            "category": self._category_from_symbol(symbol),
            "symbol": symbol.upper(),
            "limit": min(limit, 200)
        }
        if start_ms: p["startTime"] = start_ms
        if end_ms:   p["endTime"]   = end_ms
        j = _request_json("GET", url, params=p)
        rows = (j.get("result", {}) or {}).get("list", []) or []
        out: List[FundingPoint] = []
        for it in rows:
            out.append(FundingPoint(
                ts=int(it.get("fundingRateTimestamp")),
                rate=float(it.get("fundingRate")),
                exchange="Bybit",
                symbol=symbol.upper()
            ))
        out.sort(key=lambda x: x.ts)
        return out

    def funding_latest(self, symbol: str) -> Optional[FundingPoint]:
        arr = self.funding_history(symbol, limit=1)
        return arr[-1] if arr else None

    def open_interest_history(self, symbol: str, interval: str="1h", limit: int=50,
                              start_ms: Optional[int]=None, end_ms: Optional[int]=None) -> List[OIPoint]:
        url = f"{self.base}/v5/market/open-interest"
        p = {
            "category": self._category_from_symbol(symbol),
            "symbol": symbol.upper(),
            "intervalTime": interval,
            "limit": min(limit, 200)
        }
        if start_ms: p["startTime"] = start_ms
        if end_ms:   p["endTime"]   = end_ms
        j = _request_json("GET", url, params=p)
        rows = (j.get("result", {}) or {}).get("list", []) or []
        out: List[OIPoint] = []
        for it in rows:
            out.append(OIPoint(
                ts=int(it.get("openInterestTimestamp")),
                open_interest=float(it.get("openInterest")),
                exchange="Bybit",
                symbol=symbol.upper(),
                meta={}
            ))
        out.sort(key=lambda x: x.ts)
        return out

    def open_interest_snapshot(self, symbol: str) -> Optional[OIPoint]:
        arr = self.open_interest_history(symbol, interval="5min", limit=1)
        return arr[-1] if arr else None


# ----------------------------
# OKX v5 (Public)
# Docs:
#  - Current funding: GET /api/v5/public/funding-rate?instId=BTC-USDT-SWAP
#  - Open interest:   GET /api/v5/public/open-interest?instType=SWAP&instId=BTC-USDT-SWAP
# Base: https://www.okx.com
# ----------------------------

class OKXV5:
    def __init__(self, base: str = "https://www.okx.com"):
        self.base = base.rstrip("/")

    def funding_current(self, symbol: str) -> Optional[FundingPoint]:
        inst_id = okx_swap_symbol(symbol)
        url = f"{self.base}/api/v5/public/funding-rate"
        j = _request_json("GET", url, params={"instId": inst_id})
        data = (j.get("data") or [])
        if not data:
            return None
        row = data[0]
        ts = int(row.get("fundingTime") or time.time() * 1000)
        return FundingPoint(
            ts=ts,
            rate=float(row.get("fundingRate")),
            exchange="OKX",
            symbol=inst_id
        )

    def open_interest_snapshot(self, symbol: str) -> Optional[OIPoint]:
        inst_id = okx_swap_symbol(symbol)
        url = f"{self.base}/api/v5/public/open-interest"
        p = {"instType": "SWAP", "instId": inst_id}
        j = _request_json("GET", url, params=p)
        data = (j.get("data") or [])
        if not data:
            return None
        row = data[0]
        ts = int(row.get("ts"))
        oi = float(row.get("oi"))
        meta = {"oiCcy": float(row.get("oiCcy")) if row.get("oiCcy") is not None else None}
        return OIPoint(ts=ts, open_interest=oi, exchange="OKX", symbol=inst_id, meta=meta)


# ----------------------------
# Deribit v2 (public, HTTP GET JSON-RPC)
# Docs:
#  - Funding history:  GET /api/v2/public/get_funding_rate_history?instrument_name=BTC-PERPETUAL&start_timestamp=...&end_timestamp=...
#  - OI snapshot:      GET /api/v2/public/ticker?instrument_name=BTC-PERPETUAL  (field: open_interest)
# Base: https://www.deribit.com
# ----------------------------

class DeribitV2:
    def __init__(self, base: str = "https://www.deribit.com"):
        self.base = base.rstrip("/")

    def funding_history(self, symbol: str, start_ms: Optional[int]=None, end_ms: Optional[int]=None, countback_hours: int=168) -> List[FundingPoint]:
        inst = deribit_perp_symbol(symbol)
        url = f"{self.base}/api/v2/public/get_funding_rate_history"
        if end_ms is None:
            end_ms = int(time.time() * 1000)
        if start_ms is None:
            start_ms = end_ms - countback_hours * 3600 * 1000
        p = {"instrument_name": inst, "start_timestamp": start_ms, "end_timestamp": end_ms}
        j = _request_json("GET", url, params=p)
        rows = (j.get("result") or [])
        out: List[FundingPoint] = []
        for it in rows:
            out.append(FundingPoint(
                ts=int(it.get("timestamp")),
                rate=float(it.get("funding_rate")),
                exchange="Deribit",
                symbol=inst
            ))
        out.sort(key=lambda x: x.ts)
        return out

    def funding_latest(self, symbol: str) -> Optional[FundingPoint]:
        arr = self.funding_history(symbol, countback_hours=12)
        return arr[-1] if arr else None

    def open_interest_snapshot(self, symbol: str) -> Optional[OIPoint]:
        inst = deribit_perp_symbol(symbol)
        url = f"{self.base}/api/v2/public/ticker"
        j = _request_json("GET", url, params={"instrument_name": inst})
        row = (j.get("result") or {})
        oi = row.get("open_interest")
        ts = row.get("timestamp")
        if oi is None or ts is None:
            return None
        return OIPoint(ts=int(ts), open_interest=float(oi), exchange="Deribit", symbol=inst, meta={})


# ----------------------------
# Convenience facade
# ----------------------------

class DerivsClient:
    """Unified access across exchanges with a simple interface."""
    def __init__(self, binance_api_key: Optional[str] = None):
        self.binance = BinanceFutures(api_key=binance_api_key)
        self.bybit = BybitV5()
        self.okx = OKXV5()
        self.deribit = DeribitV2()

    # --- Funding ---
    def funding_latest(self, exchange: str, symbol: str) -> Optional[FundingPoint]:
        ex = exchange.lower()
        if ex == "binance":
            return self.binance.funding_latest(symbol)
        if ex == "bybit":
            return self.bybit.funding_latest(symbol)
        if ex == "okx":
            return self.okx.funding_current(symbol)
        if ex == "deribit":
            return self.deribit.funding_latest(symbol)
        raise ValueError("Unsupported exchange")

    def funding_history(self, exchange: str, symbol: str, **kwargs) -> List[FundingPoint]:
        ex = exchange.lower()
        if ex == "binance":
            return self.binance.funding_history(symbol, **kwargs)
        if ex == "bybit":
            return self.bybit.funding_history(symbol, **kwargs)
        if ex == "okx":
            fp = self.okx.funding_current(symbol)
            return [fp] if fp else []
        if ex == "deribit":
            return self.deribit.funding_history(symbol, **kwargs)
        raise ValueError("Unsupported exchange")

    # --- Open Interest ---
    def oi_snapshot(self, exchange: str, symbol: str) -> Optional[OIPoint]:
        ex = exchange.lower()
        if ex == "binance":
            return self.binance.open_interest_snapshot(symbol)
        if ex == "bybit":
            return self.bybit.open_interest_snapshot(symbol)
        if ex == "okx":
            return self.okx.open_interest_snapshot(symbol)
        if ex == "deribit":
            return self.deribit.open_interest_snapshot(symbol)
        raise ValueError("Unsupported exchange")

    def oi_history(self, exchange: str, symbol: str, **kwargs) -> List[OIPoint]:
        ex = exchange.lower()
        if ex == "binance":
            return self.binance.open_interest_history(symbol, **kwargs)
        if ex == "bybit":
            return self.bybit.open_interest_history(symbol, **kwargs)
        if ex == "okx":
            snap = self.okx.open_interest_snapshot(symbol)
            return [snap] if snap else []
        if ex == "deribit":
            snap = self.deribit.open_interest_snapshot(symbol)
            return [snap] if snap else []
        raise ValueError("Unsupported exchange")


if __name__ == "__main__":
    # Manual smoke test (requires internet)
    c = DerivsClient()
    sym = "BTCUSDT"
    print("Binance funding latest:", c.funding_latest("binance", sym))
    print("Bybit funding latest:", c.funding_latest("bybit", sym))
    print("OKX funding current:", c.funding_latest("okx", sym))
    print("Deribit funding latest (BTC):", c.funding_latest("deribit", sym))

    print("Binance OI snapshot:", c.oi_snapshot("binance", sym))
    print("Bybit OI snapshot:", c.oi_snapshot("bybit", sym))
    print("OKX OI snapshot:", c.oi_snapshot("okx", sym))
    print("Deribit OI snapshot:", c.oi_snapshot("deribit", sym))
